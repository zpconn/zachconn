---
title: An informal category-theoretic approach to monads
---

In Haskell, one typically deals only with a single category, the category of types. This is commonly called `Hask`. Keep in mind that `Hask` is not just a collection (or class) of types. (It cannot be a set of types due to Russell's paradox.) It also contains morphisms between types. These are just functions.

A functor is a structure-preserving map from one category to another. This means that each object of the source category is associated with an object of the target category *and* each morphism of the source category is associated with a morphism of the target category. The mapping of morphisms must be compatible and consistent with the mapping of objects in the obvious way (i.e., a morphsim between two objects in the source category must be mapped to a morphism between the two associated objects in the target category). A functor from a category to itself is an endofunctor: scary name, simple concept.

An endofunctor in `Hask` thus has to do two things. It has to be a type constructor (that is, map types to types, since types are the objects of `Hask`), and it has to also be a map of morphisms that is compatible with the type constructor. In Haskell, that's the job of `fmap`, and both properties are therefore represented in the familiar `Functor` typeclass. (Note that what is called a functor in Haskell parlance is actually an endofunctor.)

A natural transformation is a structure-preserving map of functors. There's a fairly intuitive way to deal with this second layer of abstraction. Given a source category \\(C\\) and two functors mapping \\(C\\) to a target category \\(D\\), each of these functors represents one possible image of \\(C\\) in \\(D\\). A natural transformation between these functors is then an expression of some structured relationship between these images of \\(C\\). In our case, all categories involved are `Hask`, so a natural transformation is a relationship between two images of `Hask` in itself.

A monad is an endofunctor on `Hask` along with two special natural transformations. Recall that the endofunctor comes equipped with a type constructor, say \\(T\\). The first natural transformation, called *return* or *lift*, is from \\(I\\) to \\(T\\), where \\(I\\) is the identity functor that has no effect. The second natural transformation, called *join*, is from \\(T\\circ T\\) to \\(T\\).

The lift natural transformation takes a value of type \\(x\\) and produces a value of type \\(T(x)\\). It must be able to do this without any special knowledge of the type \\(x\\), which means it can only build a value of type \\(T(x)\\) in the most "generic" way. For instance, in the list monad this operation takes an object, say of type `Int`, and it produces an object of type `[Int]`. (Which value, specifically, might it produce? Of course, just the singleton list whose element is precisely the provided integer.)

The join natural transformation is a bit more interesting. It takes a value of type \\(T(T(x))\\) and produces a value of the simpler type \\(T(x)\\) -- it flattens the two successive applications of the type constructor. In the list monad, for instance, this join operation is just list concatenation -- it takes a list of lists and produces a single list.

*join* is typically the more interesting of the two operations since it has a greater opportunity to delve into the monad's unique structure. *lift* on the other hand in a universal sense must always be as simple as possible since it knows nothing specific about the underlying type `x` that it's operating on.

In practice, we obtain the following intuition from the above category-theoretic approach. Any endofunctor \\(T\\) gives rise to three images of `Hask` in itself, specifically those produced by the endofunctors \\(I\\), \\(T\\), and \\(T\\circ T\\). A monad for an endofunctor \\(T\\) is then a pair of structured maps, one of which goes "up" from the first image to the second and the other of which goes "down" from the third image to the second. 

We often speak of computations "in the monad" \\(T\\), and in practice this means that we're operating within the second of these three images of `Hask`, using a rich interplay between the two natural transformations in order to move values into this image whenever needed. The lift transformation lets us inject values that aren't in this image into it; the join transformation lets us pull values back into this image if they "leak" into the third image \\(T\\circ T\\). This "leaking" can easily happen in practice; for instance, you may apply a function of type \\(a\\rightarrow \\text{Maybe } a\\) to a value of type \\(\\text{Maybe } b\\), but join allows us to transform the composite into a function of type \\(\\text{Maybe }b\\rightarrow \\text{Maybe }b\\). This specific usage of join is called "bind" in Haskell parlance and shows up in the official monad typeclass as the `>>=` operator. Implementations of the join transformation in real-world monads often contain the most nontrivial logic that is specific to the monad.